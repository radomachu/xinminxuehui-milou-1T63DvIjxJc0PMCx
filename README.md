[合集 - 技术札纪——有限硬件与无限计算的权衡艺术(39)](https://github.com)

[1.书本介绍：技术札纪——有限硬件与无限计算的权衡艺术07-24](https://github.com/poemyang/p/19002322)[2.书本大纲：从芯片、分布式到云计算AI时代07-25](https://github.com/poemyang/p/19004265)[3.我的代码背叛了我？为什么 a=1, b=2，最后x和y都等于0？07-25](https://github.com/poemyang/p/19004704)[4.我的代码出现幻觉？说好的a = 1； x = b，怎么成了x = b； a = 1？07-28](https://github.com/poemyang/p/19008983)[5.为什么i++不是原子操作？一个让无数并发程序崩溃的“常识”07-29](https://github.com/poemyang/p/19010948)[6.没有Happens-Before？你的多线程代码就是‘一锅粥’！07-30](https://github.com/poemyang/p/19012883)[7.Hello World背后藏着什么秘密？一行代码看懂Java的“跨平台”魔法07-31](https://github.com/poemyang/p/19014740)[8.a+b=c，处理器一步搞定，Java虚拟机为啥要四步？08-01](https://github.com/poemyang/p/19016482)[9.“同声传译”还是“全文翻译”？为何HotSpot虚拟机仍要保留解释器？08-04](https://github.com/poemyang/p/19020937)[10.“代码跑着跑着，就变快了？”——揭秘Java性能幕后引擎：即时编译器08-05](https://github.com/poemyang/p/19022518)[11.Java编译器优化秘籍：字节码背后的IR魔法与常见技巧08-06](https://github.com/poemyang/p/19024509)[12.解锁硬件潜能：Java向量化计算，性能飙升W倍！08-07](https://github.com/poemyang/p/19026352)[13.new出来的对象，不一定在堆上？聊聊Java虚拟机的优化技术：逃逸分析08-08](https://github.com/poemyang/p/19027777)[14.性能优化之母：为什么说“方法内联”是编译器优化中最关键的一步棋？08-11](https://github.com/poemyang/p/19031406)[15.从纳秒到毫秒的“时空之旅”：CPU是如何看待内存与硬盘的？08-12](https://github.com/poemyang/p/19033086)[16.硬盘性能提升100倍的秘密：看懂顺序I/O的魔力08-14](https://github.com/poemyang/p/19038725)[17.十年大厂员工终明白：MySQL性能优化的尽头，是对B+树的极致理解08-18](https://github.com/poemyang/p/19043960)[18.Facebook内部都在用的存储引擎，LSM凭什么能硬扛亿级写入流量？08-21](https://github.com/poemyang/p/19050442)[19.千亿消息“过眼云烟”？Kafka把硬盘当内存用的性能魔法，全靠这一手！08-22](https://github.com/poemyang/p/19052513):[westworld加速](https://westworldjs.com)[20.RPC的三大问题：跨语言、跨平台通信的终极解决方案是如何炼成的？08-27](https://github.com/poemyang/p/19060527)[21.从文本到二进制：HTTP/2不止于性能，更是对HTTP/1核心语义的传承与革新08-28](https://github.com/poemyang/p/19061836)[22.从HPACK到多路复用，揭秘HTTP/2如何终结网络拥堵08-29](https://github.com/poemyang/p/19063734)[23.站在巨人的肩膀上：gRPC通过HTTP/2构建云原生时代的通信标准09-01](https://github.com/poemyang/p/19068100)[24.gRPC不是银弹：为内网极致性能，如何设计自己的RPC协议？09-03](https://github.com/poemyang/p/19071487)[25.从JSON到Protobuf，深入序列化方案的选型与原理09-04](https://github.com/poemyang/p/19073206)[26.“卧槽，系统又崩了！”——别慌，这也许是你看过最通俗易懂的分布式入门09-05](https://github.com/poemyang/p/19074847)[27.海量数据如何“安家”？一文读懂哈希、范围和一致性哈希三大分片策略09-08](https://github.com/poemyang/p/19079520)[28.“你还活着吗？” “我没死，只是网卡了！”——来自分布式世界的“生死契约”09-09](https://github.com/poemyang/p/19082361)[29.“凭什么说你比我先？”——没有上帝时钟，如何判断“谁先谁后”？09-12](https://github.com/poemyang/p/19087563)[30.“鸡蛋不能放一个篮子里”，如何确保千亿数据万无一失？09-15](https://github.com/poemyang/p/19092154)[31.系统里数据又“打架”了？让“少数服从多数”来终结这场混乱！09-18](https://github.com/poemyang/p/19097975)[32.技术圈的“绯闻女孩”：Gossip是如何把八卦秘密传遍全网的？09-19](https://github.com/poemyang/p/19100196)[33.绯闻女孩不只会八卦：从“验明正身”到“抓内鬼”，Gossip的进阶玩法09-20](https://github.com/poemyang/p/19101931)[34.从混沌到秩序：Java共享内存模型如何通过显式约束驯服并发？09-23](https://github.com/poemyang/p/19106679)[35.一把锁的两种承诺：synchronized如何同时保证互斥与内存可见性？09-24](https://github.com/poemyang/p/19108676)[36.从MESA模型到锁升级：synchronized性能逆袭的底层逻辑09-25](https://github.com/poemyang/p/19110705)[37.揭秘JUC：volatile与CAS，并发编程的两大基石09-27](https://github.com/poemyang/p/19114881)[38.“不要通过共享内存来通信”——深入理解Golang并发模型与CSP理论10-13](https://github.com/poemyang/p/19139419)

39.Goroutine间的“灵魂管道”：Channel如何实现数据同步与因果传递？10-14

收起

Channel是连接Goroutine的“管道”，是CSP理念在Golang中的具象化实现。它不仅是数据传递的队列，更是Goroutine间同步的天然工具，让开发者无需诉诸显式的锁或条件变量。

```
func main() {
	ch := make(chan int, 1) // 创建一个int，缓冲区大小为1的Channel
	ch <- 2                 // 将2发送到ch

	go func() {  // 开启一个异步Goroutine
		n, ok := <-ch // n接收从ch发出的值，如果没有接收到数据，将会阻塞等待
		if ok {
			fmt.Println(n) // 2
		}
	}()

	close(ch) // 关闭Channel
}
```

**Channel数据结构**
Channel 在运行时使用src/runtime/chan.go 结构体表示。我们在 Go 语言中创建新的 Channel 时，实际上创建的是如下所示的结构。

```
type hchan struct {
	qcount   uint           // 队列中所有数据总数
	dataqsiz uint           // 环形队列的 size
	buf      unsafe.Pointer // 指向 dataqsiz 长度的数组
	elemsize uint16         // 元素大小
	closed   uint32
	elemtype *_type         // 元素类型
	sendx    uint           // 已发送的元素在环形队列中的位置
	recvx    uint           // 已接收的元素在环形队列中的位置
	recvq    waitq          // 接收者的等待队列
	sendq    waitq          // 发送者的等待队列

	lock mutex
}
```

![image](https://img2024.cnblogs.com/blog/757914/202510/757914-20251014221111235-872587501.png)

runtime.hchan 结构体中的五个字段 qcount、dataqsiz、buf、sendx、recv 构建底层的循环队列。除此之外，elemsize 和 elemtype 分别表示当前 Channel 能够收发的元素类型和大小。
sendq 和 recvq 存储了当前 Channel 由于缓冲区空间不足而阻塞的 Goroutine 列表，这些等待队列使用双向链表 runtime.waitq表示，链表中所有的元素都是runtime.sudog 结构。

```
type waitq struct {
    first *sudog 
    last  *sudog
}
```

runtime.sudog（Scheduling Unit Descriptor）是用于实现Goroutine调度的一种数据结构。它包含了与Goroutine相关的信息，如Goroutine的状态、等待的条件、等待的时间等。
当一个Goroutine需要等待某个事件或条件时，它会创建一个runtime.sudog，并将其加入到等待队列中。当事件或条件满足时，等
待队列中的runtime.sudog会被唤醒，从而允许对应的Goroutine继续执行。
Channel发送数据
1）如果等待接收的队列recvq中存在Goroutine，那么直接把正在发送的值发送给等待接收的Goroutine。
![image]()

2）当缓冲区未满时，找到sendx所指向的缓冲区数组的位置，将正在发送的值拷贝到该位置，并增加sendx索引以及释放锁。

![image]()

3）如果是阻塞发送，那么就将当前的Goroutine打包成一个sudog结构体，并加入到Channel的发送队列sendq里。

![image]()

之后则调用goparkunlock将当前Goroutine设置为\_Gwaiting状态并解锁，进入阻塞状态等待被唤醒；如果被调度器唤醒，执行清理
工作并最终释放对应的sudog结构体。

**Channel接收数据**
1）如果等待发送的队列sendq里存在挂起的Goroutine，那么有两种情况：当前Channel无缓冲区，或者当前Channel已满。从sendq中取出最先阻塞的Goroutine，然后调用recv方法，此时需做如下判断:

1. 如果无缓冲区，那么直接从sendq接收数据；
2. 如果缓冲区已满，从buf队列的头部接收数据，并把数据加到buf队列的尾部；
3. 最后调用goready函数将等待发送数据的Goroutine的状态从\_Gwaiting置为\_Grunnable，等待下一次调度。
   当缓冲区已满时的处理过程。

![image]()

2）如果缓冲区buf中还有元素，那么就走正常的接收，将从buf中取出的元素拷贝到当前协程的接收数据目标内存地址中。值得注意的是，即使此时Channel已经关闭，仍然可以正常地从缓冲区buf中接收数据。
3）如果是阻塞模式，且当前没有数据可以接收，那么就需要将当前Goroutine打包成一个sudog加入到Channel的等待接收队列recvq中，将当前Goroutine的状态置为\_Gwaiting，等待唤醒。

![image]()

**Channel与happens-before 关系**
Channel happens-before 规则有 4 条。
1）对一个元素的send操作happens-before对应的receive 完成操作。

```
var c = make(chan int, 10) // buffered或者unbuffered
var a string

func f() {
   // a 的初始化 happens-before 往ch中发送数据
	a = "hello, world"
   c <- 0
}

func main() {
	go f()
    // 往ch发送数据 happens-before 从ch中读取出数据
	<-c
   // 打印a的值 happens-after 第12行
   // 打印a的结果值“hello world”
	print(a)
}
```

2）对Channel的close操作happens-before receive 端的收到关闭通知操作。

```
var c = make(chan int, 10) // buffered或者unbuffered
var a string

func f() {
   // a 的初始化 happens-before close ch
	a = "hello, world"
   close(c)
}

func main() {
	go f()
    // close ch happens-before 从ch中读取出数据
	<-c
   // 打印a的值 happens-after 第12行
   // 打印a的结果值“hello world”
	print(a)
}
```

3）对于Unbuffered Channel，对一个元素的receive 操作happens-before对应的send完成操作。

```
var c = make(chan int) // unbuffered
var a string

func f() {
   // a 的初始化 happens-before 从ch中读取出数据
	a = "hello, world"
   <-c
}

func main() {
	go f()
    // 从ch中读取出数据 happens-before 往ch发送数据
	c <- 0   
   // 打印a的值 happens after 第12行
   // 打印a的结果值“hello world”
	print(a)
}
```

4）如果 Channel 的容量是 c（c>0），那么，第 n 个 receive 操作 happens-before 第 n+c 个 send 的完成操作。规则3是规则4 c=0时的特例。

**Channel使用场景**
1）并发控制：通过控制带缓冲的Channel 的队列大小来限制并发的数量。

```
func worker(id int, sem chan struct{}) {
	// 获取许可
	sem <- struct{}{}
	time.Sleep(time.Second) // 模拟耗时操作
	// 释放许可
	<-sem
}

func main() {
	// 创建一个缓冲区为2的Channel
	sem := make(chan struct{}, 2)

	for i := 0; i < 5; i++ {
		go worker(i, sem)
	}
}
```

2）信号通知：使用一个无缓冲的 Channel 来通知一个 Goroutine 任务已经完成。

```
func main() {
	done := make(chan bool)

	go func() {
		time.Sleep(2 * time.Second) // 模拟耗时操作
		// 发送信号表示工作已完成
		done <- true
	}()

	<-done // 等待信号
}
```

3）异步操作结果获取：在一个 Goroutine 中执行异步操作，然后通过 Channel 将结果发送到另一个 Goroutine。

```
func asyncTask() <-chan int {
	ch := make(chan int)
	go func() {
		// 模拟异步操作
		time.Sleep(2 * time.Second)
		ch <- 1 // 发送结果
		close(ch)
	}()
	return ch
}

func main() {
	ch := asyncTask()
	time.Sleep(1 * time.Second) // 模拟其他操作
	result := <-ch // 获取异步操作的结果
}
```

**总结：控制与编排，殊途同归**
Java 与 Golang 在并发模型上的差异，深刻地体现了两种构建程序确定性的不同哲学：
1）Java (共享内存)：采用显式同步的路径。它为开发者提供了强大的底层控制能力（锁、内存屏障），但要求开发者必须承担起预见并管理资源竞态的心智负担。确定性来自于对临界区和内存可见性的严格手工控制。
2）Golang (消息传递)：采用隐式因果的路径。它通过 Channel 将数据的所有权在 Goroutine 间传递，将并发问题从“共享数据访问”转化为“数据流设计”。确定性来自于消息传递建立的自然因果顺序，从而在结构上规避了竞态。
Java的路径是“先有并发，后加约束”，而Golang的路径是“通过约束，实现并发”。两者并非优劣之分，而是针对不同问题域和开发哲学的选择。Java的完备工具集赋予了处理极端复杂场景的灵活性，而Golang的简约设计则为构建清晰、可靠、易于推理的并发系统提供了优雅的范式。
最终，无论是显式的同步约束，还是隐式的因果传递，它们都通向并发编程的圣杯——在多核时代，构建出可预测、可维护且高性能的软件系统。这两种思想的碰撞与融合，正持续推动着现代并发编程的演进。

**很高兴与你相遇！如果你喜欢本文内容，记得关注哦**
